<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>对称二叉树</title>
  </head>
  <body>
    <script>
      /*
        给你一个二叉树的根节点 root ， 检查它是否轴对称。
        示例 1：
                  1
                /   \
               2     2
              / \   / \
             3   4 4   3
          输入：root = [1, 2, 2, 3, 4, 4, 3]
          输出：true
        示例 2：
                  1
                /   \
               2     2
                \     \
                 3     3
          输入：root = [1, 2, 2, null, 3, null, 3]
          输出：false
        */

      /* class Nodes {
        constructor(value) {
          this.value = value
          // 左右节点
          this.left = this.right = undefined
        }
      }

      // 构建二叉树数据结构
      class Tree {
        constructor(data) {
          // 临时存储所有节点
          let nodeList = []
          // 顶节点
          let root
          for (let i = 0; i < data.length; i++) {
            // 数据变成节点
            let node = new Nodes(data[i])
            nodeList.push(node)
            if (i > 0) {
              // 计算当前节点属于哪一层，
              let n = Math.floor(Math.sqrt(i + 1))

              // 当前层的起始点 因为每层是 2 的 n 次方减 1
              let c = Math.pow(2, n) - 1
              // 记录上一层的起始点
              let p = Math.pow(2, n - 1) - 1

              // 找到当前节点的父节点
              // console.log(p + Math.floor((i - c) / 2))
              let parent = nodeList[p + Math.floor((i - c) / 2)]
              // console.log(parent)
              // 把当前节点和 上一层的父节点关联起来
              // 判断是否有左节点，已有那就复制给又节点，因为二叉树只有左右两个节点
              if (parent.left) {
                parent.right = node
              } else {
                parent.left = node
              }
            }
          }
          // 取出第一个根节点
          root = nodeList.shift()
          nodeList.length = 0
          return root
        }

        // 验证对称 二叉树
        // 递归把 二叉树的 左右节点比较
        static isSymmetry(root) {
          if (!root) {
            return false
          }
          let verify = (left, right) => {
            if (!left && !right) {
              return true
            }
            // 左或右 没有，或者 左右 的值不相等
            if (
              (left && !right) ||
              (!left && right) ||
              left.value !== right.value
            ) {
              return false
            }
            return (
              verify(left.left, right.right) && verify(left.right, right.left)
            )
          }

          return verify(root.left, root.right)
        }
      }

      const res = new Tree([1, 2, 2, 3, 4, 4, 3])
      console.log(res)
      console.log('校验二叉树', Tree.isSymmetry(res)) // true */

      // 步骤一：模拟一个对称二叉树和非对称二叉树
      // 对称二叉树
      const symmetricalTree = {
        val: 1,
        left: {
          val: 2,
          left: { val: 3, left: null, right: null },
          right: { val: 4, left: null, right: null }
        },
        right: {
          val: 2,
          left: { val: 4, left: null, right: null },
          right: { val: 3, left: null, right: null }
        }
      }
      // 非对称二叉树
      const binaryTree = {
        val: 1,
        left: { val: 2, left: null, right: null },
        right: { val: 3, left: null, right: null }
      }

      // 步骤二：利用递归实现对称二叉树判断
      /**
       * Definition for a binary tree node.
       * function TreeNode(val) {
       *     this.val = val;
       *     this.left = this.right = null;
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {boolean}
       */
      var isSymmetric = function (root) {
        if (!root) return true

        return d(root.left, root.right)

        function d(p, q) {
          if (!p && !q) return true

          if (p && q && p.val === q.val) {
            return d(p.left, q.right) && d(p.right, q.left)
          } else {
            return false
          }
        }
      }

      console.log(isSymmetric(symmetricalTree)) // true
      console.log(isSymmetric(binaryTree)) // false
    </script>
  </body>
</html>
